default_platform :ios

require 'json'

# The number of times the stress test suite is ran
stress_tests_cycles = 50

before_all do
  if is_ci
    setup_ci()
  end
end

desc "Build .xcframeworks"
lane :build_xcframeworks do
  output_directory = "#{Dir.pwd}/../Products"
  ["StreamChatUI", "StreamChat"].each do |scheme|
    create_xcframework(
      project: "StreamChat.xcodeproj",
      scheme: scheme,
      destinations: ["iOS"],
      include_BCSymbolMaps: true,
      include_debug_symbols: true,
      xcframework_output_directory: output_directory,
      remove_xcarchives: true
    )
    sh("../Scripts/removeUnneededSymbols.sh", scheme, output_directory)
  end
end

desc "Release a new version"
lane :release do |options|
  # ensure_git_status_clean unless options[:no_ensure_clean]

  # Ensure we have a release type
  UI.user_error!("Please use type parameter with one of the options: type:patch, type:minor, type:major") unless ["patch", "minor", "major"].include?(options[:type])

  # Ensure We Have the GITHUB Token
  UI.user_error!("Please set GITHUB_TOKEN environment value. See https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token") unless !ENV["GITHUB_TOKEN"].nil?

  # Version Number
  version_number = increment_version_number_in_plist(bump_type: options[:type], xcodeproj: "StreamChat.xcodeproj", target: "StreamChat")

  # Checkout New Release Branch
  sh("git checkout -b " + "release/" + version_number)

  if git_tag_exists(tag: version_number)
    UI.user_error!("Tag for version #{version_number} already exists!")
  end

  # Set version on the SDK & Project
  increment_version_number_in_plist(version_number: version_number, xcodeproj: "StreamChat.xcodeproj", target: "StreamChat")
  set_SDK_version(version: version_number)
  increment_version_number_in_plist(version_number: version_number, xcodeproj: "StreamChat.xcodeproj", target: "StreamChatUI")

  changes = touch_changelog(release_version: version_number)

   # Make sure the podspecs actually build before pushing
   # Disabled now since `StreamChatUI` pod lints it against `StreamChat`s latest version instead of `main` branch
  #pod_lib_lint(podspec: "StreamChat.podspec", allow_warnings: true)
  #pod_lib_lint(podspec: "StreamChatUI.podspec", allow_warnings: true)

  version_bump_podspec(path: "StreamChat.podspec", version_number: version_number)
  version_bump_podspec(path: "StreamChatUI.podspec", version_number: version_number)

  sh("git add -A")

  if(!prompt(text: "Will commit changes. All looking good?", boolean: true))
    UI.user_error!("Not committing changes")
  end

  sh("git commit -m 'Bump #{version_number}'")

  if(!prompt(text: "Will push changes. All looking good?", boolean: true))
    UI.user_error!("Not pushing changes")
  end

  push_to_git_remote(tags: false)

  # Open a new PR
  create_pull_request(
    api_token: ENV["GITHUB_TOKEN"],
    repo: "GetStream/stream-chat-swift",
    title: "#{version_number} Release",
    head: "release/#{version_number}",
    base: "main",
    body: "#{changes}"
)

  UI.success("Successfully started release #{version_number}")
end

desc "Completes an SDK Release"
lane :complete_release do |options|
  version = options[:version]
  github_release = set_github_release(
                     repository_name: "GetStream/stream-chat-swift",
                     api_token: ENV["GITHUB_TOKEN"],
                     name: version,
                     tag_name: version,
                     description: changes
                   )
  # The & operator makes sure truthy values are converted to bool
  # and falsy (false and nil) values are converted to bool false
  push_pods(sync: options[:sync] & true)

  # Set tag
  sh("git tag #{version}")

  # Push tag to remote
  push_to_git_remote(tags: true)

  # Create TestFlight Build
  testflight_build

  # Success
  UI.success("Github release was created, please visit #{github_release["url"]} to see it")
end

desc "Pushes the StreamChat and StreamChatUI SDK podspecs to Cocoapods trunk"
lane :push_pods do |options|
  # First pod release will not have any problems
  pod_push(path: "StreamChat.podspec", allow_warnings: true)

  def release_ui(sync)
    begin
      pod_push(path: "StreamChatUI.podspec", allow_warnings: true, synchronous: sync)
    rescue
      puts "pod_push failed. Waiting a minute until retry for trunk to get updated..."
      sleep(60) # sleep for a minute, wait until trunk gets updates
      release_ui(sync)
    end
  end

  puts "Sleeping for 2 minutes for trunk to get updated..."
  sleep(60 * 2)
  release_ui(options[:sync])
end

lane :set_SDK_version do |options|
  pathToVersionFile = "../Sources/StreamChat/Generated/SystemEnvironment+Version.swift"
  versionGeneratedFile = "
//
// Copyright © 2021 Stream.io Inc. All rights reserved.
//
// ⚠️  Generated file, please use `fastlane :bump_SDK_version or fastlane release major|minor|patch` lanes

import Foundation

extension SystemEnvironment {
  /// A Stream Chat version.
  public static let version: String = \"#{options[:version]}\"
}
"
  File.write(pathToVersionFile, versionGeneratedFile)
end

desc "If `readonly: true` (by default), installs all Certs and Profiles necessary for development and ad-hoc.\nIf `readonly: false`, recreates all Profiles necessary for development and ad-hoc, updates them locally and remotely."
lane :match_me do |options|
  # Get `:readonly` value, fallback to `true` if it's missing.
  readonly = options.fetch(:readonly) { true }

  ["development", "adhoc", "appstore"].each do |type|
    match(
      type: type,
      app_identifier: [
        "io.getstream.StreamChat",
        "io.getstream.iOS.ChatDemoApp",
        "io.getstream.iOS.ChatDemoApp.DemoAppPush",
        "io.getstream.iOS.iMessageClone",
        "io.getstream.iOS.SlackClone",
        "io.getstream.iOS.MessengerClone",
        "io.getstream.iOS.YouTubeClone",
        "io.getstream.iOS.DemoAppSwiftUI"
      ],
      readonly: readonly,
      force_for_new_devices: !is_ci
    )
  end
end

desc "Register new device, regenerates profiles, updates them remotely and locally"
lane :register_new_device_and_recreate_profiles do
  device_name = prompt(text: "Enter the device name: ")
  device_udid = prompt(text: "Enter the device UDID: ")

  register_device(
    name: device_name,
    udid: device_udid
  )

  match_me(readonly: false)
end

desc "Builds the latest version of Demo app and uploads it to Firebase"
lane :distribute_demo_app do

  increment_build_number_in_plist(
    xcodeproj: "StreamChat.xcodeproj",
    target: "DemoApp",
    build_number: ENV["GITHUB_SHA"][0...7],
  )

  match_me

  gym(
    project: "StreamChat.xcodeproj",
    scheme: "DemoApp",
    configuration: "Release",
    export_method: "ad-hoc",
    export_options: "./fastlane/firebase_export_options.plist",
    silent: true,
    clean: true,
    include_symbols: true,
    output_directory: "./dist"
  )

  message = changelog_from_git_commits(commits_count: 10)

  firebase_app_distribution(
      app: "1:674907137625:ios:9e7b1074941f8728d7f348",
      groups: "ios-stream-testers",
      release_notes: message
  )
end

desc "Builds the latest version of Demo app and uploads it to TestFlight"
lane :testflight_build do

  # Ask around if you're wandering where you can get this key from
  api_key = app_store_connect_api_key(
    key_id: "MT3PRT8TB7",
    issuer_id: "69a6de96-0738-47e3-e053-5b8c7c11a4d1",
    key_content: ENV["APPSTORE_API_KEY"],
    in_house: false
  )

  # We take the version of the latest build available on TestFlight to find out the next available build number
  build_number = latest_testflight_build_number(
    app_identifier: "io.getstream.iOS.ChatDemoApp",
    api_key: api_key
  )

  # If version number is different from %d.%d.%d e.g. 3.2.1-beta-6.0 we won't be able to build a test flight build
  # so we take the current version and strip first %d.%d.%d out of it
  version_number = get_version_number(
    xcodeproj: "StreamChat.xcodeproj",
    target: "StreamChat"
  )[/\d+\.\d+\.\d/]

  ["StreamChat", "StreamChatUI"].each do |target|
    increment_version_number_in_plist(
      version_number: version_number,
      xcodeproj: "StreamChat.xcodeproj",
      target: target
    )
  end

  increment_build_number_in_plist(
    xcodeproj: "StreamChat.xcodeproj",
    target: "DemoApp",
    build_number: (build_number + 1).to_s,
  )

  increment_build_number_in_plist(
    xcodeproj: "StreamChat.xcodeproj",
    target: "DemoAppPush",
    build_number: (build_number + 1).to_s,
  )

  match_me

  gym(
    project: "StreamChat.xcodeproj",
    scheme: "DemoApp",
    configuration: "Release",
    export_method: "app-store",
    export_options: "./fastlane/testflight_export_options.plist", # We have to pass manually since `gym` detects profiles from `match` and that breaks it
    clean: true,
    include_symbols: true,
    output_directory: "archives"
  )

  changelog = "This is the official sample app built with Stream’s iOS Chat SDK v4.0. It’s designed to highlight engaging features and new improvements to the SDK, but remember that this is just one possible implementation. You can start your own by borrowing and customizing the code from this sample, or build something completely different using Stream’s components."

  pilot(
    api_key: api_key,
    team_id: "118902954",
    app_identifier: "io.getstream.iOS.ChatDemoApp",
    app_platform: "ios",
    ipa: "archives/ChatSample.ipa",
    groups: ['Public'],
    distribute_external: true,
    reject_build_waiting_for_review: true,
    changelog: changelog
  )
end

desc "Get next PR number from github to be used in CHANGELOG"
lane :get_next_issue_number do
  result = github_api(api_token: ENV["FASTLANE_GITHUB_TOKEN"], path: "/repos/GetStream/stream-chat-swift/issues")

  next_issue_number = result[:json][0]["number"] + 1
  next_issue_link = "[##{next_issue_number}](https://github.com/GetStream/stream-chat-swift/issues/#{next_issue_number})"

  clipboard(value: next_issue_link)

  UI.success "The next PR / Issue will have number: #{next_issue_number}"
  UI.success "So the next markdown link is: #{next_issue_link}"
  UI.success "Next markdown link is copied to your clipboard! ⬆️"
end

# Adds "CI=TRUE" environment variable to the provided test plan file
def setCIEnvironmentVariable(testPlanFile)
  file = File.read(testPlanFile)
  data_hash = JSON.parse(file)

  # Create the `environmentVariableEntries` array if it doesn't exist
  data_hash['defaultOptions']['environmentVariableEntries'] ||= []

  # Append the `CI` ENV variable
  data_hash['defaultOptions']['environmentVariableEntries'] << {"key"=>"CI", "value"=>"TRUE"}
  File.write(testPlanFile, JSON.pretty_generate(data_hash))

  puts "✅ `CI=TRUE` ENV variable added to " + testPlanFile
  puts "Current testplan ENV variables:"
  puts data_hash['defaultOptions']['environmentVariableEntries']
end

desc "Runs tests in Debug config"
lane :test do |options|

  setCIEnvironmentVariable("../Tests/StreamChatTests/StreamChatTestPlan.xctestplan")

  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChat",
    testplan: "StreamChatTestPlan",
    configuration: "Debug",
    clean: true,
    devices: options[:device],
    build_for_testing: options[:build_for_testing]
    )
end

desc "Runs ui tests in Debug config"
lane :test_ui do |options|

  setCIEnvironmentVariable("../Tests/StreamChatUITests/StreamChatUITestPlan.xctestplan")

  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChatUI",
    testplan: "StreamChatUITestPlan",
    configuration: "Debug",
    clean: true,
    devices: options[:device],
    build_for_testing: options[:build_for_testing]
  )
end

desc "Runs ui tests in Release config"
lane :test_ui_release do |options|

  setCIEnvironmentVariable("../Tests/StreamChatUITests/StreamChatUITestPlan.xctestplan")

  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChatUI",
    testplan: "StreamChatUITestPlan",
    configuration: "ReleaseTests",
    clean: true,
    devices: options[:device]
  )
end

desc "Runs tests in Release config"
lane :test_release do |options|

  setCIEnvironmentVariable("../Tests/StreamChatTests/StreamChatTestPlan.xctestplan")

  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChat",
    testplan: "StreamChatTestPlan",
    configuration: "ReleaseTests",
    clean: true,
    devices: options[:device]
  )
end

desc "Runs tests in Release config on macOS"
lane :test_release_macos do

  setCIEnvironmentVariable("../Tests/StreamChatTests/StreamChatTestPlan.xctestplan")

  match_macos()

  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChat",
    testplan: "StreamChatTestPlan",
    configuration: "ReleaseTests",
    clean: true,
    disable_xcpretty: true,
    destination: 'platform=macOS,arch=x86_64' # will select first from macOS and macOS Catalyst. Let's hope it always will be macOS
  )
end

desc "Runs tests in Debug config on macOS"
lane :test_debug_macos do

  setCIEnvironmentVariable("../Tests/StreamChatTests/StreamChatTestPlan.xctestplan")

  match_macos()

  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChat",
    testplan: "StreamChatTestPlan",
    configuration: "Debug",
    clean: true,
    disable_xcpretty: true,
    destination: 'platform=macOS,arch=x86_64' # will select first from macOS and macOS Catalyst. Let's hope it always will be macOS
  )
end

def match_macos
  ["development", "appstore"].each do |type|
    match(
      type: type,
      app_identifier: "io.getstream.StreamChat",
      platform: "macos"
    )
  end
end

desc "Runs stress tests for Debug config"
lane :stress_test do
  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChat",
    clean: true,
    build_for_testing: true,
    devices: options[:device]
  )

  setCIEnvironmentVariable("../Tests/StreamChatTests/StreamChatStressTestPlan.xctestplan")

  stress_tests_cycles.times {
    scan(
      project: "StreamChat.xcodeproj",
      scheme: "StreamChat",
      test_without_building: true,
      testplan: "StreamChatStressTestPlan",
      devices: options[:device],
      xcpretty_args: "--test" # simplify logs
    )
  }
end

desc "Runs stress tests in Release config"
lane :stress_test_release do |options|
  scan(
    project: "StreamChat.xcodeproj",
    scheme: "StreamChat",
    configuration: "ReleaseTests",
    clean: true,
    build_for_testing: true,
    devices: options[:device]
  )

  setCIEnvironmentVariable("../Tests/StreamChatTests/StreamChatStressTestPlan.xctestplan")

  stress_tests_cycles.times {
    scan(
      project: "StreamChat.xcodeproj",
      scheme: "StreamChat",
      configuration: "ReleaseTests",
      test_without_building: true,
      testplan: "StreamChatStressTestPlan",
      devices: options[:device],
      xcpretty_args: "--test" # simplify logs
    )
  }
end

desc "Builds Sample app"
lane :build_sample do |options|
  build_example_app("StreamChatSample", options)
end

desc "Builds Demo app"
lane :build_demo do |options|
  build_example_app("DemoApp", options)
end

desc "Builds iMessageClone app"
lane :build_imessage_clone do |options|
  build_example_app("iMessage", options)
end

desc "Builds SlackClone app"
lane :build_slack_clone do |options|
  build_example_app("Slack", options)
end

desc "Builds MessengerClone app"
lane :build_messenger_clone do |options|
  build_example_app("Messenger", options)
end

desc "Builds YouTubeClone app"
lane :build_youtube_clone do |options|
  build_example_app("YouTube", options)
end

def build_example_app(scheme, options)
  scan(
    project: "StreamChat.xcodeproj",
    scheme: scheme,
    clean: true,
    build_for_testing: true,
    devices: options[:device],
  )
end

desc "Build Docs Snippets target"
lane :build_docs_snippets do |options|
  scan(
    project: "StreamChat.xcodeproj",
    scheme: "DocsSnippets",
    clean: true,
    build_for_testing: true,
    devices: options[:device]
  )
end

desc "Test SPM Integration"
lane :spm_integration do |options|
  build_app(
    project: "Integration/SPM/SwiftPackageManager.xcodeproj",
    scheme: "SwiftPackageManager",
    skip_package_ipa: true,
    skip_archive: true,
    destination: "generic/platform=iOS Simulator"
  )
end

desc "Test CocoaPods Integration"
lane :cocoapods_integration do

  cocoapods(
    clean_install: true,
    podfile: "Integration/CocoaPods/"
  )

  build_app(
    workspace: "Integration/CocoaPods/CocoaPods.xcworkspace",
    scheme: "CocoaPods",
    skip_package_ipa: true,
    skip_archive: true,
    clean: true,
    destination: "generic/platform=iOS Simulator"
  )
end

desc "Build and upload DemoApp to Emerge"
lane :emerge_upload do
  # Build and upload Release config
  build_ios_app(
    project: "StreamChat.xcodeproj",
    scheme: "DemoApp",
    skip_package_ipa: true,
    skip_archive: false,
    clean: true,
  )

  if is_ci
    if ENV["GITHUB_EVENT_NAME"] == 'pull_request'
      pr_num = ENV["GITHUB_PR_NUM"]
      # The commit SHA has to be passed from workflow
      # see https://stackoverflow.com/questions/68061051/get-commit-sha-in-github-actions
      sha = ENV["GITHUB_COMMIT_SHA"]
    else
      # This is a PR merge to main
      pr_num = nil
      sha = ENV["GITHUB_SHA"]
    end
    repo_name = ENV["GITHUB_REPOSITORY"]
  else
    pr_num = nil
    commit = last_git_commit
    sha = commit[:commit_hash]
    repo_name = 'GetStream/stream-chat-swift'
  end

  emerge(
    build_type: "release",
    repo_name: repo_name,
    pr_number: pr_num,
    sha: sha
  )
end
