//
// Copyright Â© 2020 Stream.io Inc. All rights reserved.
//

import Foundation

/// An `AttachmentPayload` represents an object describing attachment data that is received from backend.
struct AttachmentPayload<ExtraData: AttachmentExtraData>: Decodable {
    private enum CodingKeys: String, CodingKey {
        case title
        case author = "author_name"
        case text
        case type
        case image
        case url
        case name
        case titleLink = "title_link"
        case thumbURL = "thumb_url"
        case fallback
        case imageURL = "image_url"
        case assetURL = "asset_url"
        case ogURL = "og_scrape_url"
        case actions
    }
    
    /// A title for the attachment.
    let title: String
    /// An author generated by backend after enriching URL. (e.g `YouTube`)
    let author: String?
    /// A description text.
    let text: String?
    /// A type (see `AttachmentType`).
    let type: AttachmentType
    /// Actions from a command (see `Action`, `Command`).
    let actions: [AttachmentAction]
    /// A URL.
    let url: URL?
    /// An image preview URL.
    let imageURL: URL?
    /// A file description (see `AttachmentFile`).
    let file: AttachmentFile?
    /// An extra data for the attachment.
    let extraData: ExtraData
    
    /// Hash used to uniquely identify an object to store it in DB.
    var hash: String {
        [title, author, text, type.rawValue, url?.absoluteString, imageURL?.absoluteString]
            .compactMap { $0 }
            .reduce("", +)
    }
    
    /// Init an attachment.
    ///
    /// - Parameters:
    ///   - type: an attachment type.
    ///   - title: a title.
    ///   - url: an url.
    ///   - imageURL: an preview image url.
    ///   - file: a file description.
    ///   - extraData: an extra data.
    init(
        type: AttachmentType,
        title: String,
        url: URL? = nil,
        imageURL: URL? = nil,
        file: AttachmentFile? = nil,
        extraData: ExtraData = .defaultValue
    ) {
        self.type = type
        self.url = url
        self.imageURL = imageURL
        self.title = title
        self.file = file
        self.extraData = extraData
        text = nil
        author = nil
        actions = []
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let author = try container.decodeIfPresent(String.self, forKey: .author)
        self.author = author
        var text = try container.decodeIfPresent(String.self, forKey: .text)?.trimmingCharacters(in: .whitespacesAndNewlines)
        
        title = (
            try container.decodeIfPresent(String.self, forKey: .title)
                ?? container.decodeIfPresent(String.self, forKey: .fallback)
                ?? container.decodeIfPresent(String.self, forKey: .name)
                ?? ""
        ).trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Parse imageURL.
        imageURL = AttachmentPayload.fixedURL(
            try container.decodeIfPresent(String.self, forKey: .image)
                ?? container.decodeIfPresent(String.self, forKey: .imageURL)
                ?? container.decodeIfPresent(String.self, forKey: .thumbURL)
        )
        
        // Parse URL.
        url = AttachmentPayload.fixedURL(
            try container.decodeIfPresent(String.self, forKey: .assetURL)
                ?? container.decodeIfPresent(String.self, forKey: .url)
                ?? container.decodeIfPresent(String.self, forKey: .titleLink)
                ?? container.decodeIfPresent(String.self, forKey: .ogURL)
        )
        
        let type: AttachmentType
        
        if let typeString = try? container.decode(String.self, forKey: .type) {
            let existsType = AttachmentType(rawValue: typeString)
            
            if existsType == .video {
                if author == "GIPHY" {
                    type = .giphy
                    text = nil
                } else if let url = url, url.absoluteString.contains("youtube") {
                    type = .youtube
                } else {
                    type = existsType
                }
            } else {
                type = existsType
            }
        } else if (try? container.decodeIfPresent(String.self, forKey: .ogURL)) != nil {
            type = .link
        } else {
            type = .custom(nil)
        }
        
        self.type = type
        self.text = text
        file = (type == .file || type == .video) ? try AttachmentFile(from: decoder) : nil
        actions = try container.decodeIfPresent([AttachmentAction].self, forKey: .actions) ?? []
        extraData = try .init(from: decoder)
    }
    
    /// Helper function to unify URL format for links coming from backend.
    private static func fixedURL(_ urlString: String?) -> URL? {
        guard let string = urlString else {
            return nil
        }
        
        var urlString = string
        
        if urlString.hasPrefix("//") {
            urlString = "https:\(urlString)"
        }
        
        if !urlString.lowercased().hasPrefix("http") {
            urlString = "https://\(urlString)"
        }
        
        return URL(string: urlString)
    }
}
