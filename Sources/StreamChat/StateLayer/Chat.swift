//
// Copyright Â© 2024 Stream.io Inc. All rights reserved.
//

import Foundation

@available(iOS 13.0, *)
public final class Chat {
    private let channelUpdater: ChannelUpdater
    private let loadMessagesInteractor: LoadMessagesInteractor
    private let sendMessageInteractor: SendMessageInteractor
    private let typingEventsSender: TypingEventsSender
    
    public let cid: ChannelId
    public let channelListQuery: ChannelListQuery?
    public let channelQuery: ChannelQuery

    init(
        cid: ChannelId,
        channelQuery: ChannelQuery,
        channelListQuery: ChannelListQuery?,
        messageOrdering: MessageOrdering = .topToBottom,
        channelUpdater: ChannelUpdater,
        client: ChatClient,
        environment: Environment = .init()
    ) {
        self.channelQuery = ChannelQuery(cid: cid, channelQuery: channelQuery)
        self.channelListQuery = channelListQuery
        self.cid = cid
        self.channelUpdater = channelUpdater
        loadMessagesInteractor = environment.loadMessagesInteractorBuilder(
            cid,
            messageOrdering,
            channelUpdater,
            client.messageRepository
        )
        sendMessageInteractor = environment.sendMessageInteractorBuilder(
            channelUpdater,
            client.eventNotificationCenter,
            client.messageSender
        )
        typingEventsSender = environment.typingEventsSenderBuilder(
            client.databaseContainer,
            client.apiClient
        )
        state = ChatState(cid: cid, messageOrder: messageOrdering)
        
        Task {
            try await loadFirstPage()
        }
    }
    
    public internal(set) var state: ChatState
    
    // MARK: - Disabling/Freezing the Channel
    
    /// Freezes the channel which disallows sending new messages and adding or deleting reactions.
    ///
    /// Sending a message to a frozen channel will result in a error. Sending and deleting
    /// reactions to frozen channels will result in a 403 (Not Allowed) error. User roles
    /// with the `UseFrozenChannel` permission are still able to use frozen channels as if they
    /// weren't frozen. By default no user role has the `UseFrozenChannel` permission.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func freeze() async throws {
        try await channelUpdater.freezeChannel(true, cid: cid)
    }
    
    /// Removes the frozen channel restriction and enables sending new messages and adding or deleting reactions.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func unfreeze() async throws {
        try await channelUpdater.freezeChannel(false, cid: cid)
    }
    
    // MARK: - Messages
    
    /// Sends a message to channel.
    ///
    /// The send message method waits until the network request has finished to Stream API.
    ///
    /// - Parameters:
    ///   - text: Text of the message.
    ///   - attachments: An array of the attachments for the message.
    ///     `Note`: can be built-in types, custom attachment types conforming to `AttachmentEnvelope` protocol
    ///     and `ChatMessageAttachmentSeed`s.
    ///   - replyTo: An id of the replied (quoted) message.
    ///   - mentions: An array of mentioned user ids.
    ///   - pinning: If pinning configuration is set, the message is pinned to the channel.
    ///   - extraData: Additional extra data of the message object.
    ///   - silent: If true, the message doesn't increase the unread messages count and mark a channel as unread.
    ///   - skipPushNotification: If true, skips sending push notification to channel members.
    ///   - skipEnrichUrl: If true, the url preview won't be attached to the message.
    ///   - messageId: A custom id for the sent message. By default, it is automatically generated by Stream.
    ///
    /// - Throws: An error while sending a message to the Stream API.
    /// - Returns: An instance of `ChatMessage` which was delivered to the channel.
    @discardableResult
    public func sendMessage(
        with text: String,
        attachments: [AnyAttachmentPayload] = [],
        replyTo: MessageId? = nil,
        mentions: [UserId] = [],
        pinning: MessagePinning? = nil,
        extraData: [String: RawJSON] = [:],
        silent: Bool = false,
        skipPushNotification: Bool = false,
        skipEnrichUrl: Bool = false,
        messageId: MessageId? = nil
    ) async throws -> ChatMessage {
        try await sendMessageInteractor.sendMessage(
            with: text,
            in: cid,
            attachments: attachments,
            messageId: messageId,
            mentionedUserIds: mentions,
            quotedMessageId: replyTo,
            pinning: pinning,
            silent: silent,
            skipPush: skipPushNotification,
            skipEnrichUrl: skipEnrichUrl,
            extraData: extraData
        )
    }
    
    /// Loads more preceding messages to ``ChatState.messages``.
    ///
    /// - Parameters:
    ///   - messageId: The message id of the message from which older messages are loaded.
    ///   - limit: The limit for the page size. The default limit is 25.
    ///
    /// - Throws: An error while fetching more messages from the Stream API.
    public func loadPreviousMessages(before messageId: MessageId? = nil, limit: Int? = nil) async throws {
        try await loadMessagesInteractor.loadMorePrecedingMessages(to: state, channelQuery: channelQuery, before: messageId, limit: limit)
    }
    
    /// Loads more succeeding messages to ``ChatState.messages``.
    ///
    /// - Parameters:
    ///   - messageId: The message id of the message from which newer messages are loaded.
    ///   - limit: The limit for the page size. The default limit is 25.
    ///
    /// - Throws: An error while fetching more messages from the Stream API.
    public func loadNextMessages(after messageId: MessageId? = nil, limit: Int? = nil) async throws {
        try await loadMessagesInteractor.loadMoreSucceedingMessages(to: state, with: channelQuery, after: messageId, limit: limit)
    }
    
    /// Loads messages around the given message id.
    ///
    /// Useful for jumping to a message which hasn't been loaded yet.
    ///
    /// - Note: Jumping to a messages resets the ``ChatState.messages``.
    ///
    /// - Parameters:
    ///   - messageId: The message id of the middle message in the loaded list of messages.
    ///   - limit: The limit for the page size. The default limit is 25.
    ///
    /// - Throws: An error while fetching more messages from the Stream API.
    public func loadMessagesAround(messageId: MessageId, limit: Int? = nil) async throws {
        try await loadMessagesInteractor.loadMoreMessages(to: state, with: channelQuery, around: messageId, limit: limit)
    }
    
    /// Loads messages for the first page.
    ///
    /// - Note: Loading the first page resets the ``ChatState.messages``.
    ///
    /// - Throws: An error while fetching more messages from the Stream API.
    public func loadFirstPage() async throws {
        try await loadMessagesInteractor.loadFirstPage(to: state, with: channelQuery)
    }
    
    // MARK: - Muting or Hiding the Channel
    
    /// Mutes the channel which disables push notifications and unread count for new messages.
    ///
    /// By default, mutes stay in place indefinitely until the user removes it.
    ///
    /// - Note: The list of muted channels and their expiration time is returned when the user connects.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func mute() async throws {
        try await channelUpdater.muteChannel(true, cid: cid)
    }
    
    /// Unmutes the channel which enables push notifications and unread count changes for new messages.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func unmute() async throws {
        try await channelUpdater.muteChannel(false, cid: cid)
    }
    
    /// Hide the channel which removes if from the query channel requests for that user until a new message is added.
    ///
    /// Hiding a channel is only available to members of that channel. Hidden channels may still have unread messages
    /// and you may wish to mark the channel as read prior to hiding it.
    ///
    /// Optionally you can also clear the entire message history of that channel for the user. This way,
    /// when a new message is received, it will be the only one present in the channel.
    ///
    /// - Note: You can retrieve the list of hidden channels using the `hidden` query parameter (``FilterKey.hidden``).
    ///
    /// - Parameter clearHistory: If true, the whole channel history is deleted. The default value is false.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func hide(clearHistory: Bool = false) async throws {
        try await channelUpdater.hideChannel(cid: cid, clearHistory: clearHistory)
    }
    
    /// Shows a previously hidden channel.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func show() async throws {
        try await channelUpdater.showChannel(cid: cid)
    }
    
    // MARK: - Typing Indicator
    
    /// Sends a `typing.start` event in this channel to the server.
    ///
    /// Keystroke events are throttled and `stopTyping(parentMessageId:)` is automatically called after a couple of seconds from the last keystroke event.
    ///
    /// - Parameter parentMessageId: A message id of the message in a thread the user is replying to.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func keystroke(parentMessageId: MessageId? = nil) async throws {
        // TODO: Missing capabilities check
        try await typingEventsSender.keystroke(in: cid, parentMessageId: parentMessageId)
    }
    
    /// Sends a `typing.stop` event in this channel to the server.
    ///
    /// - Note: The stop typing event is automatically sent after a few seconds since the last keystroke. Use this method only when it is required to send the event at a different time.
    ///
    /// - Parameter parentMessageId: A message id of the message in a thread the user is replying to.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func stopTyping(parentMessageId: MessageId? = nil) async throws {
        // TODO: Missing capabilities check
        // TODO: Call stopTyping when sending and editing messages
        try await typingEventsSender.stopTyping(in: cid, parentMessageId: parentMessageId)
    }
    
    // MARK: Updating the Channel
    
    /// The update operation updates all of the channel data.
    ///
    /// - Warning: Any data that is present on the channel and is not included in a full update will be **deleted**.
    ///
    /// - Parameters:
    ///   - name: - name: The name of the channel.
    ///   - imageURL: The channel avatar URL.
    ///   - team: The team for the channel.
    ///   - members: A list of members for the channel.
    ///   - invites: A list of users who will get invites.
    ///   - extraData: Extra data for the new channel.
    ///
    /// - Throws: An error while communicating with the Stream API.
    public func update(
        name: String?,
        imageURL: URL?,
        team: String?,
        members: Set<UserId> = [],
        invites: Set<UserId> = [],
        extraData: [String: RawJSON] = [:]
    ) async throws {
        try await channelUpdater.update(
            channelPayload: .init(
                cid: cid,
                name: name,
                imageURL: imageURL,
                team: team,
                members: members,
                invites: invites,
                extraData: extraData
            )
        )
    }
    
    /// The update operation updates only specified fields and retain existing channel data.
    ///
    /// A partial update can be used to set and unset specific fields when it is necessary to retain additional custom data fields on the object (a patch style update).
    public func updatePartial(
        name: String? = nil,
        imageURL: URL? = nil,
        team: String? = nil,
        members: Set<UserId> = [],
        invites: Set<UserId> = [],
        extraData: [String: RawJSON] = [:],
        unsetProperties: [String] = []
    ) async throws {
        try await channelUpdater.updatePartial(
            channelPayload: .init(
                cid: cid,
                name: name,
                imageURL: imageURL,
                team: team,
                members: members,
                invites: invites,
                extraData: extraData
            ),
            unsetProperties: unsetProperties
        )
    }
}

// MARK: - Environment

@available(iOS 13.0, *)
extension Chat {
    struct Environment {
        var loadMessagesInteractorBuilder: (
            _ cid: ChannelId,
            _ messageOrdering: MessageOrdering,
            _ channelUpdater: ChannelUpdater,
            _ messageRepository: MessageRepository
        ) -> LoadMessagesInteractor = LoadMessagesInteractor.init
        
        var sendMessageInteractorBuilder: (
            _ channelUpdater: ChannelUpdater,
            _ eventNotificationCenter: EventNotificationCenter,
            _ messageSender: MessageSender
        ) -> SendMessageInteractor = SendMessageInteractor.init
        
        var typingEventsSenderBuilder: (
            _ database: DatabaseContainer,
            _ apiClient: APIClient
        ) -> TypingEventsSender = TypingEventsSender.init
    }
}

// MARK: - Needs Review

private extension ChatClient {
    // TODO: Needs a better solution
    var messageSender: MessageSender {
        backgroundWorkers.compactMap { $0 as? MessageSender }.first!
    }
}
