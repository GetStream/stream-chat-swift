//
// Copyright Â© 2021 Stream.io Inc. All rights reserved.
//

import Foundation

/// A protocol for attachment model objects that are created from database `AttachmentDTO` objects and exposed.
public protocol ChatMessageAttachment {
    var type: AttachmentType { get }
    var id: AttachmentId? { get }
}

/// A protocol for attachment objects being manipulated outside the SDK and can be sent to backend without prior uploading.
public protocol AttachmentEnvelope: Encodable {
    var type: AttachmentType { get }
}

/// A type for custom attachment types introduced outside the SDK that will be exposed in `_ChatMessage<ExtraData: ExtraDataTypes>`
/// `data` property contains raw JSON data received from backend.
/// In order to transform this to attachment of your concrete type you should introduce custom attachment type and decode it from
/// `data` using `Decodable` protocol.
public struct ChatMessageRawAttachment: ChatMessageAttachment {
    public let id: AttachmentId?
    public let type: AttachmentType
    public let data: Data?
}

/// A type for default built-in attachment types. Used for both exposing it in `_ChatMessage<ExtraData: ExtraDataTypes>` and
/// sending back to backend if attachment doesn't need prior uploading. (Public sending API is in progress)
public struct ChatMessageDefaultAttachment: ChatMessageAttachment, AttachmentEnvelope, Decodable {
    private enum CodingKeys: String, CodingKey {
        case title
        case author = "author_name"
        case text
        case type
        case image
        case url
        case name
        case titleLink = "title_link"
        case thumbURL = "thumb_url"
        case fallback
        case imageURL = "image_url"
        case assetURL = "asset_url"
        case ogURL = "og_scrape_url"
        case actions
    }

    /// A unique identifier of the attachment.
    public var id: AttachmentId?
    /// When a new attachment is created, this value contains the URL of the source from which the attachment
    /// data are uploaded to the server. For already sent attachments this value is usually `nil`. This value is
    /// device-specific and is not synced with other devices.
    public var localURL: URL?
    /// A local attachment state
    public var localState: LocalAttachmentState?
    /// A title for the attachment.
    public let title: String
    /// An author generated by backend after enriching URL. (e.g `YouTube`)
    public let author: String?
    /// A description text.
    public let text: String?
    /// A type (see `AttachmentType`).
    public let type: AttachmentType
    /// Actions from a command (see `Action`, `Command`).
    public let actions: [AttachmentAction]
    /// A URL. Depends on type of the attachment (e.g. some asset URL, enriched URL, tappable title URL)
    public var url: URL?
    /// An image URL.
    public var imageURL: URL?
    /// An image preview URL.
    public let imagePreviewURL: URL?
    /// A file description (see `AttachmentFile`).
    public let file: AttachmentFile?
    
    init(
        id: AttachmentId,
        type: AttachmentType,
        localURL: URL?,
        localState: LocalAttachmentState?,
        title: String,
        file: AttachmentFile? = nil
    ) {
        self.id = id
        self.type = type
        self.localState = localState
        self.localURL = localURL
        self.title = title
        self.file = file
        author = nil
        text = nil
        actions = []
        imagePreviewURL = nil
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let author = try container.decodeIfPresent(String.self, forKey: .author)
        self.author = author
        text = try container.decodeIfPresent(String.self, forKey: .text)?.trimmingCharacters(in: .whitespacesAndNewlines)
        
        title = (
            try container.decodeIfPresent(String.self, forKey: .title)
                ?? container.decodeIfPresent(String.self, forKey: .fallback)
                ?? container.decodeIfPresent(String.self, forKey: .name)
                ?? ""
        ).trimmingCharacters(in: .whitespacesAndNewlines)
        
        // Parse imageURL.
        imageURL = ChatMessageDefaultAttachment.fixedURL(
            try container.decodeIfPresent(String.self, forKey: .image)
                ?? container.decodeIfPresent(String.self, forKey: .imageURL)
                ?? container.decodeIfPresent(String.self, forKey: .thumbURL)
        )
        
        imagePreviewURL = ChatMessageDefaultAttachment.fixedURL(
            try container.decodeIfPresent(String.self, forKey: .thumbURL)
        )
        
        // Parse URL.
        url = ChatMessageDefaultAttachment.fixedURL(
            try container.decodeIfPresent(String.self, forKey: .assetURL)
                ?? container.decodeIfPresent(String.self, forKey: .url)
                ?? container.decodeIfPresent(String.self, forKey: .titleLink)
                ?? container.decodeIfPresent(String.self, forKey: .ogURL)
        )
        
        let type: AttachmentType
        let itWasLinkOriginally = container.contains(.ogURL)
        if itWasLinkOriginally {
            type = .link
        } else {
            type = AttachmentType(rawValue: try? container.decode(String.self, forKey: .type))
        }
        // compiler is confused by expression unless we use helper variable for type
        self.type = type
        
        file = (type == .file || type == .video) ? try AttachmentFile(from: decoder) : nil
        actions = try container.decodeIfPresent([AttachmentAction].self, forKey: .actions) ?? []
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(title, forKey: (type == .image ? .fallback : .title))
        try container.encodeIfPresent(url, forKey: .assetURL)
        try container.encodeIfPresent(imageURL, forKey: .imageURL)
        try file?.encode(to: encoder)
    }
    
    /// Helper function to unify URL format for links coming from backend.
    private static func fixedURL(_ urlString: String?) -> URL? {
        guard let string = urlString else {
            return nil
        }
        
        var urlString = string
        
        if urlString.hasPrefix("//") {
            urlString = "https:\(urlString)"
        }
        
        if !urlString.lowercased().hasPrefix("http") {
            urlString = "https://\(urlString)"
        }
        
        return URL(string: urlString)
    }
}

/// A type designed to combine all the information required to create new attachment that needs to be uploaded before sending.
public struct ChatMessageAttachmentSeed: Hashable {
    /// A local url the data for uploading will be taken from.
    /// When an attachment in uploaded and a message is sent the `localURL` of resulting
    /// `_ChatMessageAttachment` will be equal to this value.
    public let localURL: URL
    /// When the attachment is created the filename will be available under `_ChatMessageAttachment.title` field.
    /// A `localURL.lastPathComponent` might be a good option.
    public let fileName: String
    /// An attachment type (see `AttachmentType`).
    public let type: AttachmentType

    var file: AttachmentFile {
        let fileType = AttachmentFileType(ext: localURL.pathExtension)
        return .init(
            type: fileType,
            size: localURL.fileSize,
            mimeType: fileType.mimeType
        )
    }

    /// Creates a new `ChatMessageAttachmentSeed` instance
    /// - Parameters:
    ///   - localURL: The local file URL the attachment will be uploaded from.
    ///   - fileName: The filename. Once attachment is uploaded this value will
    ///   be available under `_ChatMessageAttachment.title` field. If `nil` is provided the `localURL.lastPathComponent`
    ///   will be used.
    ///   - type: The attachment type. Attachment rendering will be chosen based on it type.
    public init(
        localURL: URL,
        fileName: String? = nil,
        type: AttachmentType
    ) {
        self.localURL = localURL
        self.fileName = fileName ?? localURL.lastPathComponent
        self.type = type
    }
}

/// A local state of the attachment. Applies only for attachments linked to the new messages sent from current device.
public enum LocalAttachmentState: Hashable {
    /// The attachment is waiting to be uploaded.
    case pendingUpload
    /// The attachment is currently being uploaded. The progress in [0, 1] range.
    case uploading(progress: Double)
    /// Uploading of the message failed. The system will not trying to upload this attachment anymore.
    case uploadingFailed
    /// The attachment is successfully uploaded.
    case uploaded
}

/// An attachment action, e.g. send, shuffle.
public struct AttachmentAction: Codable, Hashable {
    /// A name.
    public let name: String
    /// A value of an action.
    public let value: String
    /// A style, e.g. primary button.
    public let style: ActionStyle
    /// A type, e.g. button.
    public let type: ActionType
    /// A text.
    public let text: String
    
    /// Init an attachment action.
    /// - Parameters:
    ///   - name: a name.
    ///   - value: a value.
    ///   - style: a style.
    ///   - type: a type.
    ///   - text: a text.
    public init(
        name: String,
        value: String,
        style: ActionStyle,
        type: ActionType,
        text: String
    ) {
        self.name = name
        self.value = value
        self.style = style
        self.type = type
        self.text = text
    }

    /// Check if the action is cancel button.
    public var isCancel: Bool { value.lowercased() == "cancel" }
    
    /// An attachment action type, e.g. button.
    public enum ActionType: String, Codable {
        case button
    }

    /// An attachment action style, e.g. primary button.
    public enum ActionStyle: String, Codable {
        case `default`
        case primary
    }
}

/// An attachment type.
/// There are some predefined types on backend but any type can be introduced and sent to backend.
public enum AttachmentType: RawRepresentable, Codable, Hashable, ExpressibleByStringLiteral {
    /// Backend specified types.
    case image
    case video
    case audio
    case file

    /// Application custom types.
    case giphy
    case link
    case custom(String?)
    
    public var rawValue: String? {
        switch self {
        case let .custom(raw):
            return raw
        case .image:
            return "image"
        case .giphy:
            return "giphy"
        case .video:
            return "video"
        case .audio:
            return "audio"
        case .file:
            return "file"
        case .link:
            return "link"
        }
    }
        
    public init(rawValue: String?) {
        switch rawValue {
        case "image":
            self = .image
        case "giphy":
            self = .giphy
        case "video":
            self = .video
        case "audio":
            self = .audio
        case "file":
            self = .file
        case "link":
            self = .link
        default:
            self = .custom(rawValue)
        }
    }
    
    public init(from decoder: Decoder) throws {
        let rawValue = try decoder.singleValueContainer().decode(String.self)
        self = AttachmentType(rawValue: rawValue)
    }
    
    public init(stringLiteral value: String) {
        self.init(rawValue: value)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(rawValue)
    }
}

/// An attachment file description.
public struct AttachmentFile: Codable, Hashable {
    private enum CodingKeys: String, CodingKey {
        case mimeType = "mime_type"
        case size = "file_size"
    }
    
    /// An attachment file type (see `AttachmentFileType`).
    public let type: AttachmentFileType
    /// A size of the file.
    public let size: Int64
    /// A mime type.
    public let mimeType: String?
    /// A file size formatter.
    public static let sizeFormatter = ByteCountFormatter()
    
    /// A formatted file size.
    public var sizeString: String { AttachmentFile.sizeFormatter.string(fromByteCount: size) }
    
    /// Init an attachment file.
    /// - Parameters:
    ///   - type: a file type.
    ///   - size: a file size.
    ///   - mimeType: a mime type.
    public init(type: AttachmentFileType, size: Int64, mimeType: String?) {
        self.type = type
        self.size = size
        self.mimeType = mimeType
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        mimeType = try? container.decodeIfPresent(String.self, forKey: .mimeType)
        
        if let mimeType = mimeType {
            type = AttachmentFileType(mimeType: mimeType)
        } else {
            type = .generic
        }
        
        if let size = try? container.decodeIfPresent(Int64.self, forKey: .size) {
            self.size = size
        } else if let floatSize = try? container.decodeIfPresent(Float64.self, forKey: .size) {
            size = Int64(floatSize.rounded())
        } else {
            size = 0
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(size, forKey: .size)
        try container.encodeIfPresent(mimeType, forKey: .mimeType)
    }
}

/// An attachment file type.
public enum AttachmentFileType: String, Codable, Equatable, CaseIterable {
    /// A file attachment type.
    case generic, csv, doc, pdf, ppt, tar, xls, zip, mp3, mp4, mov, jpeg, png, gif
    
    private static let mimeTypes: [String: AttachmentFileType] = [
        "application/octet-stream": .generic,
        "text/csv": .csv,
        "application/msword": .doc,
        "application/pdf": .pdf,
        "application/vnd.ms-powerpoint": .ppt,
        "application/x-tar": .tar,
        "application/vnd.ms-excel": .xls,
        "application/zip": .zip,
        "audio/mp3": .mp3,
        "video/mp4": .mp4,
        "video/quicktime": .mov,
        "image/jpeg": .jpeg,
        "image/jpg": .jpeg,
        "image/png": .png,
        "image/gif": .gif
    ]
    
    /// Init an attachment file type by mime type.
    ///
    /// - Parameter mimeType: a mime type.
    public init(mimeType: String) {
        self = AttachmentFileType.mimeTypes[mimeType, default: .generic]
    }
    
    /// Init an attachment file type by a file extension.
    ///
    /// - Parameter ext: a file extension.
    public init(ext: String) {
        if ext == "jpg" {
            self = .jpeg
            return
        }
        
        self = AttachmentFileType(rawValue: ext) ?? .generic
    }
    
    /// Returns a mime type for the file type.
    public var mimeType: String {
        if self == .jpeg {
            return "image/jpeg"
        }
        
        return AttachmentFileType.mimeTypes.first(where: { $1 == self })?.key ?? "application/octet-stream"
    }
}

private extension URL {
    var fileSize: Int64 {
        let attributes = try? FileManager.default.attributesOfItem(atPath: path)
        return attributes?[.size] as? Int64 ?? 0
    }
}
